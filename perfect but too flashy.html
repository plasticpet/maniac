<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Red Orb â€“ Deep Red + Tight Yellow Spotlight</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{width:100%;height:100%;display:block;cursor:grab}
canvas:active{cursor:grabbing}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(()=>{
const c=document.getElementById('c');
const gl=c.getContext('webgl',{alpha:true,antialias:true});
if(!gl) return;
gl.getExtension('OES_standard_derivatives');

const M4={
 I(){const m=new Float32Array(16);m[0]=m[5]=m[10]=m[15]=1;return m;},
 mul(a,b){const o=new Float32Array(16);
   for(let C=0;C<4;C++)for(let R=0;R<4;R++)
     o[C*4+R]=a[R]*b[C*4]+a[4+R]*b[C*4+1]+a[8+R]*b[C*4+2]+a[12+R]*b[C*4+3];
   return o;
 },
 persp(f,a,n,fa){const t=1/Math.tan(f/2),nf=1/(n-fa);
   const m=new Float32Array(16);
   m[0]=t/a;m[5]=t;m[10]=(fa+n)*nf;m[11]=-1;m[14]=2*fa*n*nf;
   return m;
 },
 t(z){const m=M4.I();m[14]=z;return m;},
 rx(a){const c=Math.cos(a),s=Math.sin(a),m=M4.I();m[5]=c;m[6]=s;m[9]=-s;m[10]=c;return m;},
 ry(a){const c=Math.cos(a),s=Math.sin(a),m=M4.I();m[0]=c;m[2]=-s;m[8]=s;m[10]=c;return m;}
};

const VS=`
attribute vec3 p,n;
attribute vec2 u;
uniform mat4 mvp,m;
varying vec3 N;
varying vec2 U;
void main(){
 N=normalize((m*vec4(n,0.)).xyz);
 U=u;
 gl_Position=mvp*vec4(p,1.);
}`;

const FS=`
precision mediump float;
varying vec3 N;
varying vec2 U;
uniform vec3 uLight;
uniform float uPulse;
#extension GL_OES_standard_derivatives : enable

float hash(vec2 p){return fract(sin(dot(p,vec2(37.1,91.7)))*43758.5453);}
float noise(vec2 p){
 vec2 i=floor(p),f=fract(p);
 float a=hash(i),b=hash(i+vec2(1,0)),c=hash(i+vec2(0,1)),d=hash(i+1.);
 vec2 u=f*f*(3.-2.*f);
 return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;
}
float aastep(float t,float v){float fw=fwidth(v);return smoothstep(t-fw,t+fw,v);}

float scratches(vec2 uv){
 vec2 p=(uv-.5)*vec2(28.,18.);
 p.x+=sin(p.y*0.85)*0.9;
 float l=abs(fract(p.x+noise(p*0.35))-0.5);
 float s1=1.0-aastep(0.486,l);
 vec2 q=p*1.7;
 q.x+=sin(q.y*1.4)*0.4;
 float l2=abs(fract(q.x+noise(q*0.6))-0.5);
 float s2=1.0-aastep(0.493,l2);
 return clamp(s1*0.7+s2*0.45,0.0,1.0);
}

void main(){
 vec3 V=vec3(0,0,1);

 vec3 baseRed = vec3(1.35,0.005,0.01);
 vec3 spotYellow = vec3(1.75,1.60,0.10);

 vec3 L = normalize(uLight);

 float h=scratches(U);
 vec3 n2=normalize(N+vec3(h,-h,h)*0.18);

 float lam=max(dot(n2,L),0.0);
 float lam2=lam*lam;
 vec3 H=normalize(L+V);
 float spec=pow(max(dot(n2,H),0.0),190.0);

 vec3 col = baseRed * (0.55 + 0.45*lam);

 float tight = pow(lam2,2.0);
 col += spotYellow * (tight*0.85 + spec*1.6 + uPulse*0.6);

 float grain=(noise(U*420.0)-0.5)*0.03;
 col*=1.0+grain;

 col = pow(col, vec3(1.0/1.6));

 float fres=pow(1.0-max(dot(n2,V),0.0),2.2);
 float alpha=0.92+0.06*fres;

 gl_FragColor=vec4(col,alpha);
}`;

function sh(t,s){const r=gl.createShader(t);gl.shaderSource(r,s);gl.compileShader(r);return r;}
const P=gl.createProgram();
gl.attachShader(P,sh(gl.VERTEX_SHADER,VS));
gl.attachShader(P,sh(gl.FRAGMENT_SHADER,FS));
gl.linkProgram(P);
gl.useProgram(P);

gl.enable(gl.DEPTH_TEST);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

function sphere(n=240){
 const P=[],N=[],U=[],I=[];
 for(let y=0;y<=n;y++)for(let x=0;x<=n;x++){
  const u=x/n,v=y/n,th=v*Math.PI,ph=u*2*Math.PI;
  const sx=Math.sin(th)*Math.cos(ph),sy=Math.cos(th),sz=Math.sin(th)*Math.sin(ph);
  P.push(sx,sy,sz);N.push(sx,sy,sz);U.push(u,1-v);
 }
 for(let y=0;y<n;y++)for(let x=0;x<n;x++){
  const i=y*(n+1)+x;
  I.push(i,i+n+1,i+1,i+n+1,i+n+2,i+1);
 }
 return {P:new Float32Array(P),N:new Float32Array(N),U:new Float32Array(U),I:new Uint16Array(I)};
}
const m=sphere();

function buf(a,d,s){
 const l=gl.getAttribLocation(P,a);
 const b=gl.createBuffer();
 gl.bindBuffer(gl.ARRAY_BUFFER,b);
 gl.bufferData(gl.ARRAY_BUFFER,d,gl.STATIC_DRAW);
 gl.enableVertexAttribArray(l);
 gl.vertexAttribPointer(l,s,gl.FLOAT,false,0,0);
}
buf('p',m.P,3);buf('n',m.N,3);buf('u',m.U,2);
const ib=gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,m.I,gl.STATIC_DRAW);

const uLightLoc=gl.getUniformLocation(P,'uLight');
const uPulseLoc=gl.getUniformLocation(P,'uPulse');

let rx=0.2,ry=0.6,vrx=0,vry=0,dist=2.75;
let md=false,lx=0,ly=0;
let pulse=0.0;
let light=[0.55,0.95,1.15];

c.onmousedown=e=>{md=true;lx=e.clientX;ly=e.clientY};
window.onmouseup=()=>md=false;

window.onmousemove=e=>{
 const nx=e.clientX/innerWidth*2-1;
 const ny=e.clientY/innerHeight*2-1;
 light=[0.55+nx*0.35,0.95-ny*0.35,1.15];

 if(!md)return;
 const dx=e.clientX-lx,dy=e.clientY-ly;
 lx=e.clientX;ly=e.clientY;
 ry+=dx*0.005;rx+=dy*0.005;
 vry=dx*0.0012;vrx=dy*0.0012;
};

c.onclick=()=>{pulse=1.0;};
c.onwheel=e=>{e.preventDefault();dist*=e.deltaY>0?1.1:0.9};

function resize(){
 const r=Math.min(devicePixelRatio||1,2);
 c.width=innerWidth*r;c.height=innerHeight*r;
 gl.viewport(0,0,c.width,c.height);
}
addEventListener('resize',resize);resize();

const uM=gl.getUniformLocation(P,'m');
const uMVP=gl.getUniformLocation(P,'mvp');

function norm(v){const l=Math.hypot(v[0],v[1],v[2])||1;return[v[0]/l,v[1]/l,v[2]/l];}

function draw(){
 if(!md){
  ry+=vry;rx+=vrx;
  vry*=0.94;vrx*=0.94;
  if(Math.abs(vry)+Math.abs(vrx)<0.00012){vry+=0.00018;vrx+=0.00006;}
 }

 pulse*=0.82;
 gl.uniform1f(uPulseLoc,pulse);

 const L=norm(light);
 gl.uniform3f(uLightLoc,L[0],L[1],L[2]);

 gl.clearColor(0,0,0,0);
 gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

 const Pm=M4.persp(Math.PI/4,c.width/c.height,0.1,100);
 const M=M4.mul(M4.ry(ry),M4.rx(rx));
 const MVP=M4.mul(Pm,M4.mul(M4.t(-dist),M));

 gl.uniformMatrix4fv(uM,false,M);
 gl.uniformMatrix4fv(uMVP,false,MVP);

 gl.drawElements(gl.TRIANGLES,m.I.length,gl.UNSIGNED_SHORT,0);
 requestAnimationFrame(draw);
}
draw();
})();
</script>
</body>
</html>
